it is always showing no anomalies detected. harmProjects\PythonProject11\.venv\Scripts\python.exe C:\Users\user1\PycharmProjects\PythonProject11\Anomaly_detection_system.py  ‚úÖ Loaded environment variables from .env file üîë API Key loaded: sk-or-v1-f...7a68 üîß Initializing CSV Anomaly Detection System... üìÅ Target file: banking_data.csv ====================================================================== üöÄ CSV ANOMALY DETECTION SYSTEM ====================================================================== üìÇ Loading data from: banking_data.csv ‚úÖ Loaded 10 records üìä Columns found: Customer_ID, Name, DOB, Card_Opening_Year, Credit_Score, Balance, Transactions_Last_Month, Is_Anomaly ====================================================================== üìä DATA QUALITY ANALYSIS ====================================================================== üö® Potential Anomalies Found:   ‚Ä¢ 1 records with future card opening years   ‚Ä¢ 3 records where card opened before age 18 ====================================================================== üîç Detection Agent: Analyzing customer data... ‚ùå Detection error: Error code: 401 - {'error': {'message': 'User not found.', 'code': 401}} ‚úÖ No anomalies detected! ‚úÖ Results saved to anomaly_detection_results.json Process finished with exit code 0

import os
import json
import pandas as pd
from datetime import datetime
from typing import List, Dict, Any, Optional

# Load environment variables from .env file
try:
    from dotenv import load_dotenv

    load_dotenv()
    print("‚úÖ Loaded environment variables from .env file")
except ImportError:
    print("‚ö†Ô∏è  python-dotenv not installed. Install with: pip install python-dotenv")

# LangChain imports
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field

# ============================================================================
# Configuration
# ============================================================================

OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_BASE_URL = os.getenv("OPENROUTER_BASE_URL", "https://openrouter.ai/api/v1")

if not OPENROUTER_API_KEY:
    print("ERROR: OPENROUTER_API_KEY not found!")
    exit(1)

print(f"üîë API Key loaded: {OPENROUTER_API_KEY[:10]}...{OPENROUTER_API_KEY[-4:]}")

# Initialize LLM
llm = ChatOpenAI(
    model="mistralai/mistral-large",
    api_key=OPENROUTER_API_KEY,
    base_url=OPENROUTER_BASE_URL,
    temperature=0.1,
    max_tokens=2000
)

# ============================================================================
# Data Models
# ============================================================================

class DetectedAnomaly(BaseModel):
    """Model for detected anomalies"""
    customer_id: str = Field(description="Customer identifier")
    anomaly_type: str = Field(description="Type of anomaly detected")
    severity: str = Field(description="Severity: LOW, MEDIUM, HIGH, CRITICAL")
    description: str = Field(description="Description of the anomaly")
    affected_fields: List[str] = Field(description="Fields with anomalies")
    confidence_score: float = Field(description="Confidence score 0-1")


class ValidationResult(BaseModel):
    """Model for validation results"""
    customer_id: str
    is_valid_anomaly: bool = Field(description="Is this a true anomaly")
    validation_reason: str = Field(description="Reason for decision")
    requires_human_review: bool = Field(description="Needs human review")
    priority: str = Field(description="Priority: LOW, MEDIUM, HIGH, URGENT")


class ResolutionAction(BaseModel):
    """Model for resolution actions"""
    customer_id: str
    action_type: str = Field(description="Action: FIX, FLAG, ALERT, INVESTIGATE")
    suggested_fix: str = Field(description="Suggested resolution")
    automated_fix_possible: bool = Field(description="Can auto-fix")
    workflow_trigger: Optional[str] = Field(description="Workflow to trigger")


# ============================================================================
# CSV Data Processor
# ============================================================================

class CSVDataProcessor:
    """Process and validate CSV data"""

    def __init__(self, csv_file: str):
        self.csv_file = csv_file
        self.df = None
        self.data_summary = {}

    def load_data(self) -> pd.DataFrame:
        """Load and validate CSV data"""
        print(f"\nüìÇ Loading data from: {self.csv_file}")

        try:
            self.df = pd.read_csv(self.csv_file)
            print(f"‚úÖ Loaded {len(self.df)} records")

            # Display column info
            print(f"\nüìä Columns found: {', '.join(self.df.columns.tolist())}")

            # Generate data summary
            self.data_summary = {
                "total_records": len(self.df),
                "columns": self.df.columns.tolist(),
                "missing_values": self.df.isnull().sum().to_dict(),
                "data_types": self.df.dtypes.astype(str).to_dict()
            }

            return self.df

        except FileNotFoundError:
            print(f"‚ùå Error: File '{self.csv_file}' not found!")
            return None
        except Exception as e:
            print(f"‚ùå Error loading CSV: {e}")
            return None

    def get_records_as_dict(self) -> List[Dict]:
        """Convert DataFrame to list of dictionaries"""
        if self.df is None:
            return []

        # Convert to dict and handle NaN values
        records = self.df.to_dict('records')

        # Replace NaN with None for JSON compatibility
        for record in records:
            for key, value in record.items():
                if pd.isna(value):
                    record[key] = None

        return records

    def analyze_data_quality(self):
        """Analyze data quality issues"""
        if self.df is None:
            return

        print("\n" + "=" * 70)
        print("üìä DATA QUALITY ANALYSIS")
        print("=" * 70)

        # Missing values
        missing = self.df.isnull().sum()
        if missing.sum() > 0:
            print("\n‚ö†Ô∏è  Missing Values Detected:")
            for col, count in missing[missing > 0].items():
                print(f"  {col}: {count} missing ({count / len(self.df) * 100:.1f}%)")

        # Check for potential anomalies based on business rules
        anomalies_found = []

        # Check Card_Opening_Year
        if 'Card_Opening_Year' in self.df.columns:
            current_year = datetime.now().year
            future_years = self.df[self.df['Card_Opening_Year'] > current_year]
            past_years = self.df[self.df['Card_Opening_Year'] < 1950]

            if len(future_years) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(future_years)} records with future card opening years")
            if len(past_years) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(past_years)} records with unrealistic past years")

        # Check Credit_Score
        if 'Credit_Score' in self.df.columns:
            high_scores = self.df[self.df['Credit_Score'] > 850]
            low_scores = self.df[self.df['Credit_Score'] < 300]

            if len(high_scores) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(high_scores)} records with credit scores > 850")
            if len(low_scores) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(low_scores)} records with credit scores < 300")

        # Check DOB vs Card_Opening_Year
        if 'DOB' in self.df.columns and 'Card_Opening_Year' in self.df.columns:
            df_copy = self.df.copy()
            df_copy['DOB'] = pd.to_datetime(df_copy['DOB'], errors='coerce')
            df_copy['Birth_Year'] = df_copy['DOB'].dt.year
            df_copy['Age_When_Card_Opened'] = df_copy['Card_Opening_Year'] - df_copy['Birth_Year']

            underage = df_copy[df_copy['Age_When_Card_Opened'] < 18]
            if len(underage) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(underage)} records where card opened before age 18")

        # Check Balance
        if 'Balance' in self.df.columns:
            negative = self.df[self.df['Balance'] < 0]
            if len(negative) > 0:
                anomalies_found.append(f"  ‚Ä¢ {len(negative)} records with negative balance")

        if anomalies_found:
            print("\nüö® Potential Anomalies Found:")
            for anomaly in anomalies_found:
                print(anomaly)
        else:
            print("\n‚úÖ No obvious data quality issues found")

        print("=" * 70 + "\n")


# ============================================================================
# Detection Agent
# ============================================================================

class DetectionAgent:
    """AI-powered anomaly detection agent"""

    def __init__(self, llm):
        self.llm = llm
        self.detection_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert banking data analyst specialized in detecting anomalies.

Analyze customer records and identify anomalies such as:
1. IMPOSSIBLE DATES: Card opening year in the future or before customer birth
2. INVALID CREDIT SCORES: Scores outside 300-850 range
3. SUSPICIOUS BALANCES: Negative balances or unusually high for credit score
4. AGE INCONSISTENCIES: Cards opened before customer turned 18
5. TRANSACTION ANOMALIES: Unusual transaction patterns for the profile
6. DATA QUALITY ISSUES: Missing critical information

For EACH record with an anomaly, return a JSON object with:
- customer_id (as string)
- anomaly_type (one of the categories above)
- severity (LOW, MEDIUM, HIGH, CRITICAL)
- description (specific explanation)
- affected_fields (list of field names)
- confidence_score (0.0 to 1.0)

Return ONLY a JSON array, no markdown or extra text."""),
            ("human", """Analyze these customer records for anomalies:

{customer_data}

Return a JSON array of detected anomalies. If no anomalies, return empty array [].""")
        ])

    def detect_anomalies(self, records: List[Dict]) -> List[DetectedAnomaly]:
        """Detect anomalies in customer records"""
        print("\nüîç Detection Agent: Analyzing customer data...")

        customer_data = json.dumps(records, indent=2, default=str)
        messages = self.detection_prompt.format_messages(customer_data=customer_data)

        try:
            response = self.llm.invoke(messages)
            response_text = response.content.strip()

            # Clean response
            if response_text.startswith("```"):
                lines = response_text.split('\n')
                response_text = '\n'.join(lines[1:-1] if len(lines) > 2 else lines)

            anomalies_data = json.loads(response_text)

            anomalies = []
            for anomaly_dict in anomalies_data:
                try:
                    # Ensure customer_id is string
                    anomaly_dict['customer_id'] = str(anomaly_dict['customer_id'])
                    anomaly = DetectedAnomaly(**anomaly_dict)
                    anomalies.append(anomaly)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error parsing anomaly: {e}")
                    continue

            print(f"‚úÖ Detected {len(anomalies)} anomalies")
            return anomalies

        except Exception as e:
            print(f"‚ùå Detection error: {e}")
            return []


# ============================================================================
# Validation Agent
# ============================================================================

class ValidationAgent:
    """Validates detected anomalies"""

    def __init__(self, llm):
        self.llm = llm
        self.validation_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a banking compliance expert validating anomalies.

Determine if detected anomalies are:
1. TRUE POSITIVES: Real issues requiring action
2. FALSE POSITIVES: Acceptable variations or edge cases

Consider:
- Regulatory compliance requirements
- Business rules (e.g., min age 18 for credit cards)
- Data quality standards
- Risk levels

Be conservative - flag suspicious items for human review."""),
            ("human", """Validate this anomaly:

Customer ID: {customer_id}
Anomaly Type: {anomaly_type}
Severity: {severity}
Description: {description}
Affected Fields: {affected_fields}
Confidence: {confidence_score}

Customer Record:
{customer_data}

Return JSON:
{{
  "customer_id": "{customer_id}",
  "is_valid_anomaly": true,
  "validation_reason": "explanation",
  "requires_human_review": true,
  "priority": "HIGH"
}}""")
        ])

    def validate_anomaly(self, anomaly: DetectedAnomaly,
                         customer_data: Dict) -> ValidationResult:
        """Validate a detected anomaly"""
        print(f"\n‚úì Validation Agent: Validating Customer {anomaly.customer_id}...")

        messages = self.validation_prompt.format_messages(
            customer_id=anomaly.customer_id,
            anomaly_type=anomaly.anomaly_type,
            severity=anomaly.severity,
            description=anomaly.description,
            affected_fields=json.dumps(anomaly.affected_fields),
            confidence_score=anomaly.confidence_score,
            customer_data=json.dumps(customer_data, indent=2, default=str)
        )

        try:
            response = self.llm.invoke(messages)
            response_text = response.content.strip()

            if response_text.startswith("```"):
                lines = response_text.split('\n')
                response_text = '\n'.join(lines[1:-1] if len(lines) > 2 else lines)

            validation_data = json.loads(response_text)
            validation_data['customer_id'] = str(validation_data['customer_id'])
            validation = ValidationResult(**validation_data)

            status = "‚úÖ VALID" if validation.is_valid_anomaly else "‚ùå FALSE POSITIVE"
            print(f"{status} - Priority: {validation.priority}")

            return validation

        except Exception as e:
            print(f"‚ö†Ô∏è  Validation error: {e}")
            return ValidationResult(
                customer_id=str(anomaly.customer_id),
                is_valid_anomaly=True,
                validation_reason="Validation failed - defaulting to valid",
                requires_human_review=True,
                priority="HIGH"
            )


# ============================================================================
# Resolution Agent
# ============================================================================

class ResolutionAgent:
    """Suggests fixes for validated anomalies"""

    def __init__(self, llm):
        self.llm = llm
        self.resolution_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a banking operations expert providing resolution actions.

For each validated anomaly, suggest:
1. ACTION TYPE:
   - FIX: Can be corrected (data entry error)
   - FLAG: Mark account for review
   - ALERT: Notify fraud/compliance team
   - INVESTIGATE: Requires detailed investigation

2. SPECIFIC FIX: What exactly should be done
3. AUTOMATION: Can this be fixed automatically?
4. WORKFLOW: What process should be triggered?

Be specific and actionable."""),
            ("human", """Provide resolution for:

Customer ID: {customer_id}
Anomaly: {anomaly_type}
Severity: {severity}
Description: {description}
Validation: {is_valid}
Priority: {priority}

Customer Data:
{customer_data}

Return JSON:
{{
  "customer_id": "{customer_id}",
  "action_type": "INVESTIGATE",
  "suggested_fix": "specific action",
  "automated_fix_possible": false,
  "workflow_trigger": "workflow_name"
}}""")
        ])

    def suggest_resolution(self, anomaly: DetectedAnomaly,
                           validation: ValidationResult,
                           customer_data: Dict) -> ResolutionAction:
        """Suggest resolution for validated anomaly"""
        print(f"\nüîß Resolution Agent: Generating fix for Customer {anomaly.customer_id}...")

        messages = self.resolution_prompt.format_messages(
            customer_id=anomaly.customer_id,
            anomaly_type=anomaly.anomaly_type,
            severity=anomaly.severity,
            description=anomaly.description,
            is_valid=validation.is_valid_anomaly,
            priority=validation.priority,
            customer_data=json.dumps(customer_data, indent=2, default=str)
        )

        try:
            response = self.llm.invoke(messages)
            response_text = response.content.strip()

            if response_text.startswith("```"):
                lines = response_text.split('\n')
                response_text = '\n'.join(lines[1:-1] if len(lines) > 2 else lines)

            resolution_data = json.loads(response_text)
            resolution_data['customer_id'] = str(resolution_data['customer_id'])
            resolution = ResolutionAction(**resolution_data)

            print(f"üìã Action: {resolution.action_type}")
            print(f"ü§ñ Auto-fix: {'Yes' if resolution.automated_fix_possible else 'No'}")

            return resolution

        except Exception as e:
            print(f"‚ö†Ô∏è  Resolution error: {e}")
            return ResolutionAction(
                customer_id=str(anomaly.customer_id),
                action_type="INVESTIGATE",
                suggested_fix="Manual investigation required",
                automated_fix_possible=False,
                workflow_trigger="manual_review"
            )


# ============================================================================
# Orchestrator
# ============================================================================

class CSVAnomalyDetectionOrchestrator:
    """Orchestrates all three agents for CSV data processing"""

    def __init__(self, llm, csv_file: str):
        self.csv_processor = CSVDataProcessor(csv_file)
        self.detection_agent = DetectionAgent(llm)
        self.validation_agent = ValidationAgent(llm)
        self.resolution_agent = ResolutionAgent(llm)
        self.records = []

    def process(self) -> Dict[str, Any]:
        """Process CSV file through all agents"""
        print("\n" + "=" * 70)
        print("üöÄ CSV ANOMALY DETECTION SYSTEM")
        print("=" * 70)

        # Load data
        df = self.csv_processor.load_data()
        if df is None:
            return {}

        # Analyze data quality
        self.csv_processor.analyze_data_quality()

        # Get records
        self.records = self.csv_processor.get_records_as_dict()

        results = {
            "file": self.csv_processor.csv_file,
            "total_records": len(self.records),
            "data_summary": self.csv_processor.data_summary,
            "anomalies_detected": [],
            "validated_anomalies": [],
            "resolution_actions": [],
            "summary": {}
        }

        # Step 1: Detection
        detected_anomalies = self.detection_agent.detect_anomalies(self.records)
        results["anomalies_detected"] = [a.dict() for a in detected_anomalies]

        if not detected_anomalies:
            print("\n‚úÖ No anomalies detected!")
            return results

        # Step 2: Validation
        validated_anomalies = []
        for anomaly in detected_anomalies:
            customer_record = next(
                (r for r in self.records if str(r.get("Customer_ID")) == str(anomaly.customer_id)),
                {}
            )

            validation = self.validation_agent.validate_anomaly(anomaly, customer_record)
            validated_anomalies.append(validation)
            results["validated_anomalies"].append(validation.dict())

        # Step 3: Resolution
        resolution_actions = []
        for anomaly, validation in zip(detected_anomalies, validated_anomalies):
            if validation.is_valid_anomaly:
                customer_record = next(
                    (r for r in self.records if str(r.get("Customer_ID")) == str(anomaly.customer_id)),
                    {}
                )

                resolution = self.resolution_agent.suggest_resolution(
                    anomaly, validation, customer_record
                )
                resolution_actions.append(resolution)
                results["resolution_actions"].append(resolution.dict())

        # Summary
        results["summary"] = {
            "total_detected": len(detected_anomalies),
            "valid_anomalies": sum(1 for v in validated_anomalies if v.is_valid_anomaly),
            "false_positives": sum(1 for v in validated_anomalies if not v.is_valid_anomaly),
            "require_human_review": sum(1 for v in validated_anomalies if v.requires_human_review),
            "automated_fixes": sum(1 for r in resolution_actions if r.automated_fix_possible),
            "manual_actions": sum(1 for r in resolution_actions if not r.automated_fix_possible)
        }

        self._print_summary(results)

        return results

    def _print_summary(self, results: Dict):
        """Print summary report"""
        summary = results["summary"]

        print("\n" + "=" * 70)
        print("üìä DETECTION SUMMARY")
        print("=" * 70)
        print(f"Total Records Analyzed:  {results['total_records']}")
        print(f"Anomalies Detected:      {summary['total_detected']}")
        print(f"Valid Anomalies:         {summary['valid_anomalies']}")
        print(f"False Positives:         {summary['false_positives']}")
        print(f"Human Review Needed:     {summary['require_human_review']}")
        print(f"Automated Fixes:         {summary['automated_fixes']}")
        print(f"Manual Actions:          {summary['manual_actions']}")
        print("=" * 70 + "\n")


# ============================================================================
# Main Execution
# ============================================================================

if __name__ == "__main__":
    # CSV file name
    CSV_FILE = "banking_data.csv"

    print("üîß Initializing CSV Anomaly Detection System...")
    print(f"üìÅ Target file: {CSV_FILE}")

    # Initialize orchestrator
    orchestrator = CSVAnomalyDetectionOrchestrator(llm, CSV_FILE)

    # Process the CSV
    results = orchestrator.process()

    # Save results
    output_file = "anomaly_detection_results.json"
    with open(output_file, "w") as f:
        json.dump(results, f, indent=2, default=str)

    print(f"‚úÖ Results saved to {output_file}")

    # Create detailed report
    if results.get("anomalies_detected"):
        report_file = "anomaly_report.txt"
        with open(report_file, "w") as f:
            f.write("=" * 70 + "\n")
            f.write("BANKING DATA ANOMALY DETECTION REPORT\n")
            f.write("=" * 70 + "\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

            for i, anomaly in enumerate(results["anomalies_detected"], 1):
                f.write(f"\n{i}. Customer ID: {anomaly['customer_id']}\n")
                f.write(f"   Type: {anomaly['anomaly_type']}\n")
                f.write(f"   Severity: {anomaly['severity']}\n")
                f.write(f"   Description: {anomaly['description']}\n")
                f.write(f"   Affected Fields: {', '.join(anomaly['affected_fields'])}\n")
                f.write(f"   Confidence: {anomaly['confidence_score']}\n")

        print(f"üìÑ Detailed report saved to {report_file}")
